#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap = { version = "4.5.48", features = ["derive"] }
//! thiserror = "2.0.17"
//! ```
//!
//! Create a new commit with the same tree as an existing commit

use clap::Parser;
use std::io::{self, IsTerminal, Read};
use std::process::{Command, Stdio, exit};
use std::str::FromStr;
use thiserror::Error;

const EXIT_OK: i32 = 0;
const EXIT_USAGE: i32 = 64; // command line usage error
const EXIT_DATAERR: i32 = 65; // bad input / not found
const EXIT_SOFTWARE: i32 = 70; // unexpected internal failure

#[derive(Debug, Error)]
enum ValidationError {
    #[error("Git reference cannot be empty")]
    GitRefEmpty,

    #[error("Failed to execute git rev-parse")]
    GitRevParseFailed,

    #[error("Git reference not found: {ref_name}")]
    GitRefNotFound { ref_name: String },

    #[error("Failed to get commit metadata")]
    MetadataFailed,

    #[error("Unexpected metadata format from git show")]
    MetadataFormatInvalid,

    #[error("Failed to spawn git commit-tree: {details}")]
    CommitTreeSpawnFailed { details: String },

    #[error("Failed to wait for git commit-tree: {details}")]
    CommitTreeWaitFailed { details: String },

    #[error("Failed to create commit: {details}")]
    CommitCreationFailed { details: String },
}

#[derive(Debug, Clone)]
struct GitRef(String);

impl FromStr for GitRef {
    type Err = ValidationError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ValidationError::GitRefEmpty);
        }

        // Validate that the ref exists using git rev-parse
        let output = Command::new("git")
            .args(&["rev-parse", "--verify", &format!("{}^{{commit}}", s)])
            .output()
            .map_err(|_| ValidationError::GitRevParseFailed)?;

        if !output.status.success() {
            return Err(ValidationError::GitRefNotFound {
                ref_name: s.to_string(),
            });
        }

        // Store the resolved SHA
        let sha = String::from_utf8_lossy(&output.stdout).trim().to_string();
        Ok(GitRef(sha))
    }
}

impl GitRef {
    fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Parser, Debug)]
#[command(name = "git-new-from")]
#[command(about = "Create a new commit with the same tree as an existing commit", long_about = None)]
struct Args {
    /// Commit ID or reference to copy from
    commit_id: GitRef,

    /// Commit message (use '-' to read from stdin)
    #[arg(long, short)]
    message: Option<String>,

    /// Read commit message from file
    #[arg(long, short = 'F')]
    file: Option<String>,

    /// Show what would be done without making changes
    #[arg(long)]
    dry_run: bool,

    /// Show verbose output
    #[arg(long, short)]
    verbose: bool,

    /// Additional arguments to pass to git commit-tree
    #[arg(trailing_var_arg = true, allow_hyphen_values = true, hide = true)]
    extra_args: Vec<String>,
}

#[derive(Debug)]
struct CommitMetadata {
    author_name: String,
    author_email: String,
    author_date: String,
    committer_name: String,
    committer_email: String,
    committer_date: String,
}

fn main() {
    // Handle --help in raw args before clap parsing
    let raw_args: Vec<String> = std::env::args().collect();
    if raw_args.iter().any(|arg| arg == "--help" || arg == "-h") {
        Args::parse_from(&["git-new-from", "--help"]);
        return;
    }

    let args = Args::parse();

    // Check we're in a git repository
    let repo_check = Command::new("git")
        .args(&["rev-parse", "--git-dir"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .expect("Failed to execute git rev-parse");

    if !repo_check.success() {
        eprintln!("✗ ERROR: Not a git repository (or any of the parent directories).");
        eprintln!("NEXT: cd into a repo, or run: git init");
        exit(EXIT_DATAERR);
    }

    // Handle stdin for --message -
    let message = if let Some(ref msg) = args.message {
        if msg == "-" {
            if io::stdin().is_terminal() {
                eprintln!("✗ ERROR: Cannot read from stdin when stdin is a terminal");
                eprintln!(
                    "NEXT: Pipe input to this command or use --message \"text\" or --file <path>"
                );
                exit(EXIT_USAGE);
            }

            let mut stdin_content = String::new();
            if let Err(e) = io::stdin().read_to_string(&mut stdin_content) {
                eprintln!("✗ ERROR: Failed to read stdin: {}", e);
                exit(EXIT_SOFTWARE);
            }

            let stdin_content = stdin_content.trim();
            if stdin_content.is_empty() {
                eprintln!("✗ ERROR: No input provided via stdin for --message -");
                eprintln!("NEXT: Provide commit message content via stdin");
                exit(EXIT_USAGE);
            }

            Some(stdin_content.to_string())
        } else {
            args.message.clone()
        }
    } else {
        args.message.clone()
    };

    if message.is_some() && args.file.is_some() {
        eprintln!("✗ ERROR: Cannot specify both --message and --file");
        eprintln!("NEXT: Use either --message or --file, not both");
        exit(EXIT_USAGE);
    }

    if message.is_none() && args.file.is_none() {
        eprintln!("✗ ERROR: Missing required message option");
        eprintln!("NEXT: Use --message <msg> or --file <path>");
        exit(EXIT_USAGE);
    }

    // GitRef is already validated and resolved to SHA
    let metadata = match extract_commit_metadata(&args.commit_id) {
        Ok(m) => m,
        Err(e) => {
            eprintln!("✗ ERROR: {}", e);
            exit(EXIT_SOFTWARE);
        }
    };

    let parents = extract_parent_commits(&args.commit_id);
    let tree_ref = format!("{}^{{tree}}", args.commit_id.as_str());

    if args.verbose {
        println!(
            "→ Creating new commit from {}",
            &args.commit_id.as_str()[..7]
        );
        println!("  Tree: {}", tree_ref);
        let parent_str = if parents.is_empty() {
            "none (root commit)".to_string()
        } else {
            parents.join(", ")
        };
        println!("  Parents: {}", parent_str);
        println!(
            "  Author: {} <{}>",
            metadata.author_name, metadata.author_email
        );
    }

    if args.dry_run {
        println!("[DRY RUN] Would create new commit with:");
        println!("  Tree from: {}", &args.commit_id.as_str()[..7]);
        if let Some(msg) = &message {
            println!("  Message: {}", msg.lines().next().unwrap_or(""));
        } else if let Some(f) = &args.file {
            println!("  Message from file: {}", f);
        }
        println!("✓ [DRY RUN] Would successfully create commit");
        exit(EXIT_OK);
    }

    let mut message_args = vec![];
    if let Some(msg) = message {
        message_args.push("-m".to_string());
        message_args.push(msg);
    } else if let Some(f) = args.file {
        message_args.push("-F".to_string());
        message_args.push(f);
    }

    let new_commit = match create_commit(
        &tree_ref,
        &parents,
        &message_args,
        &args.extra_args,
        &metadata,
    ) {
        Ok(c) => c,
        Err(e) => {
            eprintln!("✗ ERROR: {}", e);
            exit(EXIT_SOFTWARE);
        }
    };

    if args.verbose {
        println!("✓ Created commit {}", &new_commit[..7]);
    } else {
        println!("{}", new_commit);
    }

    exit(EXIT_OK);
}

fn extract_commit_metadata(commit_id: &GitRef) -> Result<CommitMetadata, ValidationError> {
    let format = "%aN|%aE|%aI|%cN|%cE|%cI";
    let output = Command::new("git")
        .args(&[
            "show",
            "--no-patch",
            &format!("--format={}", format),
            commit_id.as_str(),
        ])
        .output()
        .map_err(|_| ValidationError::MetadataFailed)?;

    if !output.status.success() {
        return Err(ValidationError::MetadataFailed);
    }

    let fields: Vec<String> = String::from_utf8_lossy(&output.stdout)
        .trim()
        .split('|')
        .map(|s| s.to_string())
        .collect();

    if fields.len() != 6 {
        return Err(ValidationError::MetadataFormatInvalid);
    }

    Ok(CommitMetadata {
        author_name: fields[0].clone(),
        author_email: fields[1].clone(),
        author_date: fields[2].clone(),
        committer_name: fields[3].clone(),
        committer_email: fields[4].clone(),
        committer_date: fields[5].clone(),
    })
}

fn extract_parent_commits(commit_id: &GitRef) -> Vec<String> {
    let output = Command::new("git")
        .args(&["rev-parse", &format!("{}^@", commit_id.as_str())])
        .output();

    match output {
        Ok(output) if output.status.success() => String::from_utf8_lossy(&output.stdout)
            .lines()
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect(),
        _ => vec![],
    }
}

fn create_commit(
    tree_ref: &str,
    parents: &[String],
    message_args: &[String],
    extra_args: &[String],
    metadata: &CommitMetadata,
) -> Result<String, ValidationError> {
    let mut args = vec![tree_ref.to_string()];

    for parent in parents {
        args.push("-p".to_string());
        args.push(parent.clone());
    }

    args.extend_from_slice(message_args);
    args.extend_from_slice(extra_args);

    let child = Command::new("git")
        .arg("commit-tree")
        .args(&args)
        .env("GIT_AUTHOR_NAME", &metadata.author_name)
        .env("GIT_AUTHOR_EMAIL", &metadata.author_email)
        .env("GIT_AUTHOR_DATE", &metadata.author_date)
        .env("GIT_COMMITTER_NAME", &metadata.committer_name)
        .env("GIT_COMMITTER_EMAIL", &metadata.committer_email)
        .env("GIT_COMMITTER_DATE", &metadata.committer_date)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(|e| ValidationError::CommitTreeSpawnFailed {
            details: e.to_string(),
        })?;

    let output = child
        .wait_with_output()
        .map_err(|e| ValidationError::CommitTreeWaitFailed {
            details: e.to_string(),
        })?;

    if !output.status.success() {
        return Err(ValidationError::CommitCreationFailed {
            details: String::from_utf8_lossy(&output.stderr).to_string(),
        });
    }

    Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())
}
