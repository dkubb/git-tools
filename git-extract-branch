#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap = { version = "4.5.48", features = ["derive"] }
//! thiserror = "2.0.17"
//! ```
//!
//! Extract N commits of the current branch to a new branch

use clap::Parser;
use std::process::{Command, Stdio, exit};
use std::str::FromStr;
use thiserror::Error;

const EXIT_OK: i32 = 0;
const EXIT_DATAERR: i32 = 65; // bad input / not found
const EXIT_SOFTWARE: i32 = 70; // unexpected internal failure

#[derive(Debug, Error)]
enum ValidationError {
    #[error("Git reference cannot be empty")]
    GitRefEmpty,

    #[error("Failed to execute git rev-parse")]
    GitRevParseFailed,

    #[error("Git reference not found: {ref_name}")]
    GitRefNotFound { ref_name: String },
}

#[derive(Debug, Clone)]
struct GitRef {
    raw: String,
    sha: String,
}

impl FromStr for GitRef {
    type Err = ValidationError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ValidationError::GitRefEmpty);
        }

        // Validate that the ref exists using git rev-parse
        let output = Command::new("git")
            .args(&["rev-parse", "--verify", &format!("{}^{{commit}}", s)])
            .output()
            .map_err(|_| ValidationError::GitRevParseFailed)?;

        if !output.status.success() {
            return Err(ValidationError::GitRefNotFound {
                ref_name: s.to_string(),
            });
        }

        // Store the resolved SHA
        let sha = String::from_utf8_lossy(&output.stdout).trim().to_string();
        Ok(GitRef {
            raw: s.to_string(),
            sha,
        })
    }
}

impl GitRef {
    fn raw(&self) -> &str {
        &self.raw
    }

    fn sha(&self) -> &str {
        &self.sha
    }
}

#[derive(Parser, Debug)]
#[command(name = "git-extract-branch")]
#[command(about = "Extract N commits of the current branch to a new branch", long_about = None)]
struct Args {
    /// Name of the new branch to create
    new_branch: String,

    /// Number of commits to extract
    n_commits: usize,

    /// Parent commit/branch to extract from
    parent: Option<GitRef>,

    /// Master branch to base new branch on
    master: Option<GitRef>,

    /// Remote to fetch from
    #[arg(default_value = "origin")]
    remote: String,

    /// Show what would be done without making changes
    #[arg(long)]
    dry_run: bool,
}

fn main() {
    let args = Args::parse();

    // Check we're in a git repository
    let repo_check = Command::new("git")
        .args(&["rev-parse", "--git-dir"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .expect("Failed to execute git rev-parse");

    if !repo_check.success() {
        eprintln!("✗ ERROR: Not a git repository (or any of the parent directories).");
        eprintln!("NEXT: cd into a repo, or run: git init");
        exit(EXIT_DATAERR);
    }

    // Get current branch
    let branch = git_output(&["rev-parse", "--abbrev-ref", "HEAD"]);

    // Determine default branch once if either positional argument is missing
    let inferred_default = if args.parent.is_none() || args.master.is_none() {
        Some(
            resolve_default_branch(&args.remote).unwrap_or_else(|message| {
                eprintln!("✗ ERROR: {}", message);
                eprintln!("NEXT: Provide parent/master explicitly or configure init.defaultBranch");
                exit(EXIT_DATAERR);
            }),
        )
    } else {
        None
    };

    let parent_ref = if let Some(provided) = args.parent.clone() {
        provided
    } else {
        let name = inferred_default
            .as_ref()
            .expect("default branch should be available when parent is missing");
        GitRef::from_str(name).unwrap_or_else(|e| {
            eprintln!("✗ ERROR: {}", e);
            eprintln!("NEXT: Provide parent explicitly with the <parent> positional argument");
            exit(EXIT_DATAERR);
        })
    };

    let master_ref = if let Some(provided) = args.master.clone() {
        provided
    } else {
        let name = inferred_default
            .as_ref()
            .expect("default branch should be available when master is missing");
        GitRef::from_str(name).unwrap_or_else(|e| {
            eprintln!("✗ ERROR: {}", e);
            eprintln!("NEXT: Provide master explicitly with the <master> positional argument");
            exit(EXIT_DATAERR);
        })
    };

    // Get the commit hash for the Nth commit from parent
    let rev_list = git_output(&["rev-list", &format!("{}..{}", parent_ref.raw(), branch)]);

    let commits: Vec<String> = rev_list
        .lines()
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if commits.len() < args.n_commits {
        eprintln!(
            "✗ ERROR: Not enough commits. Requested {} but only {} available.",
            args.n_commits,
            commits.len()
        );
        exit(EXIT_DATAERR);
    }

    let mut cherry_commits: Vec<String> = commits.iter().take(args.n_commits).cloned().collect();
    cherry_commits.reverse(); // apply oldest → newest

    let newest_selected = cherry_commits
        .last()
        .expect("cherry_commits is non-empty after length check");

    if args.dry_run {
        println!(
            "[DRY RUN] Would extract {}: {}..{}",
            args.new_branch,
            parent_ref.raw(),
            newest_selected
        );
        println!("[DRY RUN] Would fetch {}", master_ref.raw());
        println!("[DRY RUN] Would fix branch {}", master_ref.raw());
        println!(
            "[DRY RUN] Would create branch {} from {}",
            args.new_branch,
            master_ref.raw()
        );
        println!(
            "[DRY RUN] Would cherry-pick commits (oldest→newest): {}",
            cherry_commits.join(" → ")
        );
        println!("[DRY RUN] Would fix branch {}", args.new_branch);

        if parent_ref.raw() == master_ref.raw() {
            println!("[DRY RUN] Would checkout {}", branch);
            println!("[DRY RUN] Would rebase {} onto {}", branch, args.new_branch);
            println!("[DRY RUN] Would fix branch {}", branch);
            println!("[DRY RUN] Would checkout {}", args.new_branch);
        }

        exit(EXIT_OK);
    }

    println!(
        "Extracting {}: {}..{}",
        args.new_branch,
        parent_ref.raw(),
        newest_selected
    );

    // Fetch master
    git_run(&[
        "fetch",
        &args.remote,
        &format!("{}:{}", master_ref.raw(), master_ref.raw()),
    ]);

    // Fix master branch
    git_run(&["fix-branch", master_ref.raw()]);

    // Create new branch from master
    git_run(&["checkout", "-b", &args.new_branch, master_ref.raw()]);

    // Cherry-pick the commits individually (oldest → newest)
    for commit in &cherry_commits {
        git_run(&["cherry-pick", commit]);
    }

    // Fix the new branch
    git_run(&["fix-branch", &args.new_branch]);

    // If parent is master, rebase original branch on new branch
    if parent_ref.raw() == master_ref.raw() {
        git_run(&["checkout", &branch]);
        git_run(&["rebase", &args.new_branch]);
        git_run(&["fix-branch"]);
        git_run(&["checkout", &args.new_branch]);
    }

    exit(EXIT_OK);
}

fn git_output(args: &[&str]) -> String {
    let output = match Command::new("git").args(args).output() {
        Ok(output) => output,
        Err(e) => {
            eprintln!("✗ ERROR: Failed to execute git {}", args.join(" "));
            eprintln!("DETAILS: {}", e);
            exit(EXIT_SOFTWARE);
        }
    };

    if !output.status.success() {
        eprintln!("✗ ERROR: git {} failed", args.join(" "));
        let stderr = String::from_utf8_lossy(&output.stderr);
        let trimmed = stderr.trim();
        if !trimmed.is_empty() {
            eprintln!("{}", trimmed);
        }
        exit(EXIT_SOFTWARE);
    }

    String::from_utf8_lossy(&output.stdout).trim().to_string()
}

fn git_run(args: &[&str]) {
    let status = match Command::new("git").args(args).status() {
        Ok(status) => status,
        Err(e) => {
            eprintln!("✗ ERROR: Failed to execute git {}", args.join(" "));
            eprintln!("DETAILS: {}", e);
            exit(EXIT_SOFTWARE);
        }
    };

    if !status.success() {
        eprintln!("✗ ERROR: git {} failed", args.join(" "));
        exit(EXIT_SOFTWARE);
    }
}

fn git_output_optional(args: &[&str]) -> Option<String> {
    let output = Command::new("git").args(args).output().ok()?;
    if !output.status.success() {
        return None;
    }
    let value = String::from_utf8_lossy(&output.stdout).trim().to_string();
    if value.is_empty() { None } else { Some(value) }
}

fn branch_exists(name: &str) -> bool {
    Command::new("git")
        .args(&[
            "show-ref",
            "--verify",
            "--quiet",
            &format!("refs/heads/{}", name),
        ])
        .status()
        .map(|status| status.success())
        .unwrap_or(false)
}

fn resolve_default_branch(remote: &str) -> Result<String, String> {
    if let Some(value) = git_output_optional(&["config", "init.defaultBranch"]) {
        return Ok(value);
    }

    let remote_head = format!("refs/remotes/{}/HEAD", remote);
    if let Some(symbolic) = git_output_optional(&["symbolic-ref", "--quiet", &remote_head]) {
        let prefix = format!("refs/remotes/{}/", remote);
        let trimmed = symbolic
            .strip_prefix(&prefix)
            .map(|s| s.to_string())
            .unwrap_or(symbolic);
        if !trimmed.is_empty() {
            return Ok(trimmed);
        }
    }

    for candidate in ["main", "master"] {
        if branch_exists(candidate) {
            return Ok(candidate.to_string());
        }
    }

    Err(format!(
        "Unable to determine default branch (checked init.defaultBranch, {}, and common fallbacks)",
        remote_head
    ))
}
