#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap = { version = "4.5.48", features = ["derive"] }
//! thiserror = "2.0.17"
//! which = "6.0.0"
//! ```
//!
//! Launch an interactive rebase with the git-extract sequence editor.

use clap::Parser;
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};
use std::process::{Command, exit};
use thiserror::Error;
use which::which;

const EXIT_OK: i32 = 0;
const EXIT_DATAERR: i32 = 65; // bad input / not found
const EXIT_SOFTWARE: i32 = 70; // unexpected internal failure

#[derive(Debug, Error)]
enum ExtractError {
    #[error("Sequence editor not found or not executable at: {0}")]
    EditorNotExecutable(String),

    #[error("Failed to determine script directory")]
    ScriptDirectory,

    #[error("Failed to execute git rebase: {0}")]
    GitCommand(String),
}

#[derive(Parser, Debug)]
#[command(name = "git-extract")]
#[command(about = "Extract commits by reordering history")]
struct Args {
    /// Arguments forwarded to `git rebase --interactive`
    #[arg(
        trailing_var_arg = true,
        allow_hyphen_values = true,
        required = true,
        hide = true
    )]
    rebase_args: Vec<String>,
}

fn main() {
    let args = Args::parse();

    let editor = match determine_editor() {
        Ok(path) => path,
        Err(err) => {
            eprintln!("✗ ERROR: {}", err);
            exit(EXIT_DATAERR);
        }
    };

    match run_rebase(&editor, &args.rebase_args) {
        Ok(code) => exit(code),
        Err(err) => {
            eprintln!("✗ ERROR: {}", err);
            exit(EXIT_SOFTWARE);
        }
    }
}

fn determine_editor() -> Result<String, ExtractError> {
    if let Ok(env_editor) = std::env::var("GIT_SEQUENCE_EDITOR") {
        if !env_editor.trim().is_empty() {
            return Ok(env_editor);
        }
    }

    let candidate = match script_dir() {
        Ok(dir) => dir.join("git-extract-seq-editor"),
        Err(_) => PathBuf::from("git-extract-seq-editor"),
    };

    if candidate.as_os_str().is_empty() {
        return Err(ExtractError::ScriptDirectory);
    }

    if has_path_component(&candidate) {
        validate_executable(&candidate)?;
        Ok(candidate.to_string_lossy().into_owned())
    } else {
        // No path separators: rely on PATH resolution without validation
        Ok(candidate.to_string_lossy().into_owned())
    }
}

fn script_dir() -> Result<PathBuf, ExtractError> {
    if let Some(arg0) = std::env::args().next() {
        let path = PathBuf::from(&arg0);
        if path.components().count() > 1 {
            if let Ok(canonical) = std::fs::canonicalize(&path) {
                if let Some(parent) = canonical.parent() {
                    return Ok(parent.to_path_buf());
                }
            }
        } else if let Some(found) = which(&arg0).ok() {
            if let Some(parent) = found.parent() {
                return Ok(parent.to_path_buf());
            }
        }
    }

    std::env::current_exe()
        .ok()
        .and_then(|path| path.parent().map(Path::to_path_buf))
        .ok_or(ExtractError::ScriptDirectory)
}

fn has_path_component(path: &Path) -> bool {
    path.components().count() > 1
}

fn validate_executable(path: &Path) -> Result<(), ExtractError> {
    let metadata = std::fs::metadata(path)
        .map_err(|_| ExtractError::EditorNotExecutable(path.to_string_lossy().into_owned()))?;

    let permissions = metadata.permissions();
    if permissions.mode() & 0o111 == 0 {
        return Err(ExtractError::EditorNotExecutable(
            path.to_string_lossy().into_owned(),
        ));
    }

    Ok(())
}

fn run_rebase(editor: &str, args: &[String]) -> Result<i32, ExtractError> {
    let status = Command::new("git")
        .env("GIT_SEQUENCE_EDITOR", editor)
        .arg("rebase")
        .arg("--interactive")
        .args(args)
        .status()
        .map_err(|e| ExtractError::GitCommand(e.to_string()))?;

    if status.success() {
        Ok(status.code().unwrap_or(EXIT_OK))
    } else {
        Ok(status.code().unwrap_or(EXIT_SOFTWARE))
    }
}
