#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap = { version = "4.5.48", features = ["derive"] }
//! non-empty-string = "0.2.0"
//! nonempty = "0.12.0"
//! regex = "1.11"
//! strum = { version = "0.27.2", features = ["derive"] }
//! thiserror = "2.0.17"
//! ```
//!
//! Create a conventional commit with proper formatting

use clap::{Parser, ValueEnum};
use non_empty_string::NonEmptyString;
use nonempty::NonEmpty;
use std::cmp::Ordering;
use std::collections::HashSet;
use std::fs;
use std::process::{Command, exit};
use std::str::FromStr;
use strum::IntoEnumIterator;
use thiserror::Error;

const EXIT_OK: i32 = 0;
const EXIT_USAGE: i32 = 64;
const EXIT_SOFTWARE: i32 = 70;

#[derive(Debug, Clone, Copy, ValueEnum)]
#[value(rename_all = "lowercase")]
enum CommitType {
    Build,
    Chore,
    Ci,
    Docs,
    Feat,
    Fix,
    Perf,
    Refactor,
    Style,
    Test,
    Revert,
}

impl std::fmt::Display for CommitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.to_possible_value().unwrap().get_name())
    }
}

#[derive(Debug, Error)]
enum ValidationError {
    #[error("Summary is required")]
    SummaryMissing,
    #[error("action must start with one of {allowed} - got '{word}'")]
    ActionInvalidVerb { word: String, allowed: String },
    #[error("action descriptions must contain a verb")]
    ActionMissingVerb,
}

#[derive(Debug, Clone)]
struct CommitSummary(String);

impl FromStr for CommitSummary {
    type Err = ValidationError;

    fn from_str(raw_summary: &str) -> Result<Self, Self::Err> {
        if raw_summary.trim().is_empty() {
            return Err(ValidationError::SummaryMissing);
        }
        Ok(CommitSummary(raw_summary.trim().to_string()))
    }
}

#[derive(Debug, Clone)]
struct CommitSubject(String);

impl CommitSubject {
    fn new(commit_type: CommitType, scope: Option<&NonEmptyString>, summary: &CommitSummary) -> Result<Self, ValidationError> {
        let subject = match scope {
            Some(scope) => format!("{commit_type}({}): {}", scope.as_str(), summary.0),
            None => format!("{commit_type}: {}", summary.0),
        };
        Ok(CommitSubject(subject))
    }

    fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    strum::AsRefStr,
    strum::Display,
    strum::EnumIter,
    strum::EnumString,
)]
#[repr(u8)]
enum Verb {
    Remove = 0,
    Fix = 1,
    Refactor = 2,
    Move = 3,
    Rename = 4,
    Change = 5,
    Add = 6,
    Upgrade = 7,
    Downgrade = 8,
}

impl Verb {
    fn allowed_list() -> String {
        Self::iter()
            .map(|verb| verb.to_string())
            .collect::<Vec<_>>()
            .join(" ")
    }

    fn parse(verb_str: &str) -> Result<Self, ValidationError> {
        verb_str.parse().map_err(|_err| {
            ValidationError::ActionInvalidVerb {
                word: verb_str.to_owned(),
                allowed: Self::allowed_list(),
            }
        })
    }
}

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
struct Action {
    detail: String,
    verb: Verb,
}

impl std::fmt::Display for Action {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} {}", self.verb, self.detail)
    }
}

impl Action {
    fn new(raw: &str) -> Result<Self, ValidationError> {
        let trimmed = raw.trim();
        if trimmed.is_empty() {
            return Err(ValidationError::ActionMissingVerb);
        }

        let (verb_raw, detail_raw) = trimmed
            .split_once(' ')
            .ok_or(ValidationError::ActionMissingVerb)?;
        let verb = Verb::parse(verb_raw)?;
        let detail = detail_raw.trim();
        
        // Ensure detail ends with a period
        let detail = if detail.ends_with('.') {
            detail.to_owned()
        } else {
            format!("{}.", detail)
        };
        
        Ok(Self {
            detail,
            verb,
        })
    }
}

impl PartialOrd for Action {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Action {
    fn cmp(&self, other: &Self) -> Ordering {
        match self.verb.cmp(&other.verb) {
            Ordering::Equal => self.detail.cmp(&other.detail),
            ordering @ (Ordering::Less | Ordering::Greater) => ordering,
        }
    }
}

#[derive(Clone, Debug)]
struct ActionList {
    actions: Vec<Action>,
}

impl ActionList {
    fn body(&self) -> String {
        self.actions
            .iter()
            .flat_map(|action| self.to_body_lines(action))
            .collect::<Vec<_>>()
            .join("\n")
    }

    fn to_body_lines(&self, action: &Action) -> Vec<String> {
        let mut result = Vec::new();
        let text = action.to_string();

        for raw_line in text.lines() {
            let normalized = raw_line.split_whitespace().collect::<Vec<_>>().join(" ");
            if normalized.is_empty() {
                continue;
            }
            let prefix = if result.is_empty() { "- " } else { "  " };
            result.push(format!("{prefix}{normalized}"));
        }

        result
    }

    fn from_nonempty(list: NonEmpty<Action>) -> Self {
        let mut dedup: HashSet<Action> = HashSet::from_iter(list);
        let mut actions: Vec<_> = dedup.drain().collect();
        actions.sort();
        Self { actions }
    }
}

#[derive(Parser, Debug)]
#[command(name = "git-conventional-commit")]
#[command(about = "Create a conventional commit with proper formatting", long_about = None)]
struct Args {
    #[arg(long = "action", value_name = "TEXT", required = true)]
    actions: Vec<String>,

    commit_type: CommitType,

    #[arg(long)]
    scope: Option<NonEmptyString>,

    #[arg(long)]
    summary: Option<CommitSummary>,

    #[arg(long)]
    dry_run: bool,

    #[arg(long)]
    allow_dirty: bool,

    #[arg(long, conflicts_with = "allow_dirty")]
    empty: bool,

    /// Create an autosquash reword commit for the given commit.
    /// This creates a commit equivalent to `git commit --fixup=reword:<commit>`
    /// while enforcing conventional commit validations for the new message.
    #[arg(long, value_name = "COMMIT")]
    reword: Option<String>,
}

fn main() {
    let raw_args: Vec<String> = std::env::args().collect();
    if raw_args.iter().any(|arg| arg == "--help" || arg == "-h") {
        Args::parse_from(["git-conventional-commit", "--help"]);
        return;
    }

    if raw_args.len() <= 1 {
        Args::parse_from(["git-conventional-commit", "--help"]);
        return;
    }

    let args = Args::parse();

    if !args.allow_dirty {
        match collect_unstaged_untracked() {
            Ok((unstaged, untracked)) => {
                if !unstaged.is_empty() || !untracked.is_empty() {
                    eprintln!("✗ ERROR: Unstaged or untracked changes detected");
                    eprintln!(
                        "NEXT: Stage changes or rerun with --allow-dirty to allow committing with a dirty working tree"
                    );

                    if !unstaged.is_empty() {
                        eprintln!("UNSTAGED:");
                        for path in &unstaged {
                            eprintln!("  - {}", path);
                        }
                    }

                    if !untracked.is_empty() {
                        eprintln!("UNTRACKED:");
                        for path in &untracked {
                            eprintln!("  - {}", path);
                        }
                    }

                    exit(EXIT_USAGE);
                }
            }
            Err(message) => {
                eprintln!("✗ ERROR: {}", message);
                exit(EXIT_SOFTWARE);
            }
        }
    }

    let parsed_actions = args
        .actions
        .into_iter()
        .map(|raw| Action::new(&raw))
        .collect::<Result<Vec<_>, _>>()
        .unwrap_or_else(|e| {
            eprintln!("✗ ERROR: {}", e);
            exit(EXIT_USAGE);
        });

    let non_empty = NonEmpty::from_vec(parsed_actions).unwrap();
    let action_list = ActionList::from_nonempty(non_empty);

    let summary = args
        .summary
        .as_ref()
        .ok_or_else(|| {
            eprintln!("✗ ERROR: --summary is required");
            eprintln!("NEXT: Add --summary <text>");
            exit(EXIT_USAGE);
        })
        .unwrap();

    let subject = match CommitSubject::new(args.commit_type, args.scope.as_ref(), summary) {
        Ok(s) => s,
        Err(e) => {
            eprintln!("✗ ERROR: {}", e);
            exit(EXIT_USAGE);
        }
    };

    let action_body = action_list.body();
    if action_body.contains("\n\n") {
        eprintln!("✗ ERROR: internal error: action list contains blank lines");
        eprintln!("NEXT: This should be impossible; please report this bug");
        exit(EXIT_SOFTWARE);
    }

    let conventional_message = format!("{}\n\n{}", subject.as_str(), action_body);

    let final_message = if let Some(ref commit) = args.reword {
        let output = Command::new("git")
            .args(["log", "-1", "--pretty=%s", commit])
            .output()
            .expect("Failed to execute git log");

        if !output.status.success() {
            eprintln!("✗ ERROR: failed to resolve commit '{commit}'");
            exit(output.status.code().unwrap_or(EXIT_USAGE));
        }

        let target_subject = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if target_subject.is_empty() {
            eprintln!("✗ ERROR: commit '{commit}' has an empty subject");
            exit(EXIT_USAGE);
        }

        format!("amend! {target_subject}\n\n{conventional_message}")
    } else {
        conventional_message.clone()
    };

    // Check for clean working tree when --empty is used
    if args.empty {
        let output = Command::new("git")
            .args(["status", "--porcelain"])
            .output()
            .expect("Failed to execute git status");

        if !output.status.success() {
            eprintln!("✗ ERROR: git status failed");
            exit(output.status.code().unwrap_or(EXIT_SOFTWARE));
        }

        if !String::from_utf8_lossy(&output.stdout).trim().is_empty() {
            eprintln!("✗ ERROR: working tree is not clean");
            eprintln!("NEXT: Use --allow-dirty or stage/unstage changes first");
            exit(EXIT_USAGE);
        }
    }

    if args.dry_run {
        println!("→ Commit message:");
        for line in final_message.lines() {
            println!("  {}", line);
        }
        println!("✓ [DRY RUN] Commit message would be valid");
        exit(EXIT_OK);
    }

    let mut commit_cmd = Command::new("git");
    commit_cmd
        .arg("commit");
    
    if args.empty || args.reword.is_some() {
        commit_cmd.arg("--allow-empty");
    }

    let mut tmp_dir_to_cleanup: Option<std::path::PathBuf> = None;

    if let Some(commit) = args.reword.as_deref() {
        // git commit does not allow -m/-F with --fixup=reword, so we overwrite
        // the editor buffer with our validated conventional message.
        let tmp_dir = std::env::temp_dir().join(format!(
            "git-conventional-commit-{}-{}",
            std::process::id(),
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_nanos()
        ));
        fs::create_dir_all(&tmp_dir).expect("Failed to create temp directory");

        let msg_path = tmp_dir.join("message.txt");
        fs::write(&msg_path, &final_message).expect("Failed to write temp message file");

        let editor_path = tmp_dir.join("editor.sh");
        fs::write(
            &editor_path,
            "#!/bin/sh\ncat \"$GIT_CONVENTIONAL_COMMIT_MSG\" > \"$1\"\n",
        )
        .expect("Failed to write temp editor script");

        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&editor_path)
                .expect("Failed to stat temp editor script")
                .permissions();
            perms.set_mode(0o700);
            fs::set_permissions(&editor_path, perms).expect("Failed to chmod temp editor script");
        }

        commit_cmd.arg(format!("--fixup=reword:{commit}"));
        commit_cmd.env("GIT_CONVENTIONAL_COMMIT_MSG", &msg_path);
        commit_cmd.env("GIT_EDITOR", &editor_path);

        tmp_dir_to_cleanup = Some(tmp_dir);
    } else {
        commit_cmd.arg("--message").arg(&final_message);
    }

    let status = commit_cmd.status().expect("Failed to execute git commit");

    if let Some(tmp_dir) = tmp_dir_to_cleanup {
        let _ = fs::remove_dir_all(tmp_dir);
    }

    if !status.success() {
        eprintln!("✗ ERROR: git commit failed");
        exit(status.code().unwrap_or(EXIT_SOFTWARE));
    }

    println!("✓ Commit created successfully");
}

fn collect_unstaged_untracked() -> Result<(Vec<String>, Vec<String>), String> {
    let unstaged_output = Command::new("git")
        .args(&["diff", "--name-only"])
        .output()
        .map_err(|e| format!("Failed to execute git diff --name-only: {}", e))?;

    if !unstaged_output.status.success() {
        return Err("git diff --name-only failed".to_string());
    }

    let unstaged = String::from_utf8_lossy(&unstaged_output.stdout)
        .lines()
        .map(|line| line.to_string())
        .collect();

    let untracked_output = Command::new("git")
        .args(&["ls-files", "--others", "--exclude-standard"])
        .output()
        .map_err(|e| {
            format!(
                "Failed to execute git ls-files --others --exclude-standard: {}",
                e
            )
        })?;

    if !untracked_output.status.success() {
        return Err("git ls-files --others --exclude-standard failed".to_string());
    }

    let untracked = String::from_utf8_lossy(&untracked_output.stdout)
        .lines()
        .map(|line| line.to_string())
        .collect();

    Ok((unstaged, untracked))
}
