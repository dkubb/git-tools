#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap = { version = "4.5.48", features = ["derive"] }
//! regex = "1.11"
//! thiserror = "2.0.17"
//! ```
//!
//! Create a conventional commit with proper formatting

use clap::{Parser, ValueEnum};
use regex::Regex;
use std::process::{Command, Stdio, exit};
use std::str::FromStr;
use thiserror::Error;

const EXIT_OK: i32 = 0;
const EXIT_USAGE: i32 = 64; // command line usage error
const EXIT_DATAERR: i32 = 65; // bad input / not found
const EXIT_SOFTWARE: i32 = 70; // unexpected internal failure

#[derive(Debug, Clone, Copy, ValueEnum)]
#[value(rename_all = "lowercase")]
enum CommitType {
    Fix,
    Feat,
    Docs,
    Style,
    Refactor,
    Perf,
    Test,
    Build,
    Ci,
    Revert,
}

impl std::fmt::Display for CommitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.to_possible_value().unwrap().get_name())
    }
}

#[derive(Debug, Error)]
enum ValidationError {
    #[error("Summary is required")]
    SummaryEmpty,

    #[error("Summary must be a single line")]
    SummaryMultiline,

    #[error("Summary should not end with a period")]
    SummaryEndsWithPeriod,

    #[error("Scope must be a single line")]
    ScopeMultiline,

    #[error("Scope must not contain a closing parenthesis")]
    ScopeHasClosingParen,

    #[error("Scope cannot be empty when explicitly provided")]
    ScopeEmpty,

    #[error("Body cannot be empty when explicitly provided")]
    BodyEmpty,

    #[error("Breaking note cannot be empty")]
    BreakingNoteEmpty,

    #[error("Breaking note must be a single line")]
    BreakingNoteMultiline,

    #[error("Body line too long ({len} chars). Max 72 characters per line.\nLine: {line}")]
    BodyLineTooLong { len: usize, line: String },

    #[error("Git reference cannot be empty")]
    GitRefEmpty,

    #[error("Failed to execute git rev-parse")]
    GitRevParseFailed,

    #[error("Git reference not found: {ref_name}")]
    GitRefNotFound { ref_name: String },

    #[error(
        "Subject too long ({len} > 50).\nGiven current type/scope/bang, you have ~{budget} chars for --summary.\nSubject: {subject}"
    )]
    SubjectTooLong {
        len: usize,
        budget: usize,
        subject: String,
    },
}

#[derive(Debug, Clone)]
struct CommitSummary(String);

impl FromStr for CommitSummary {
    type Err = ValidationError;

    fn from_str(raw_summary: &str) -> Result<Self, Self::Err> {
        if raw_summary.is_empty() {
            return Err(ValidationError::SummaryEmpty);
        }

        let re = Regex::new(r"\s+").unwrap();
        let summary = re.replace_all(raw_summary.trim(), " ").to_string();

        if summary.contains('\n') {
            return Err(ValidationError::SummaryMultiline);
        }

        if summary.ends_with('.') {
            return Err(ValidationError::SummaryEndsWithPeriod);
        }

        Ok(CommitSummary(summary))
    }
}

impl CommitSummary {
    fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone)]
struct CommitScope(String);

impl FromStr for CommitScope {
    type Err = ValidationError;

    fn from_str(raw_scope: &str) -> Result<Self, Self::Err> {
        let scope = raw_scope.trim();

        if scope.is_empty() {
            return Err(ValidationError::ScopeEmpty);
        }

        if scope.contains('\n') {
            return Err(ValidationError::ScopeMultiline);
        }
        if scope.contains(')') {
            return Err(ValidationError::ScopeHasClosingParen);
        }
        Ok(CommitScope(scope.to_string()))
    }
}

impl CommitScope {
    fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone)]
struct CommitBody(String);

impl FromStr for CommitBody {
    type Err = ValidationError;

    fn from_str(raw_body: &str) -> Result<Self, Self::Err> {
        let body = raw_body.trim();

        if body.is_empty() {
            return Err(ValidationError::BodyEmpty);
        }

        for line in body.lines() {
            if !line.is_empty() && line.len() > 72 {
                return Err(ValidationError::BodyLineTooLong {
                    len: line.len(),
                    line: line.to_string(),
                });
            }
        }

        Ok(CommitBody(body.to_string()))
    }
}

impl CommitBody {
    fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone)]
struct BreakingNote(String);

impl FromStr for BreakingNote {
    type Err = ValidationError;

    fn from_str(raw_note: &str) -> Result<Self, Self::Err> {
        if raw_note.is_empty() {
            return Ok(BreakingNote(String::new()));
        }

        let note = raw_note.trim();
        if note.is_empty() {
            return Err(ValidationError::BreakingNoteEmpty);
        }
        if note.contains('\n') {
            return Err(ValidationError::BreakingNoteMultiline);
        }
        Ok(BreakingNote(note.to_string()))
    }
}

impl BreakingNote {
    fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone)]
struct GitRef(String);

impl FromStr for GitRef {
    type Err = ValidationError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ValidationError::GitRefEmpty);
        }

        // Validate that the ref exists using git rev-parse
        let output = Command::new("git")
            .args(&["rev-parse", "--verify", &format!("{}^{{commit}}", s)])
            .output()
            .map_err(|_| ValidationError::GitRevParseFailed)?;

        if !output.status.success() {
            return Err(ValidationError::GitRefNotFound {
                ref_name: s.to_string(),
            });
        }

        // Store the resolved SHA
        let sha = String::from_utf8_lossy(&output.stdout).trim().to_string();
        Ok(GitRef(sha))
    }
}

impl GitRef {
    fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Debug, Clone)]
struct CommitSubject(String);

impl CommitSubject {
    fn new(
        commit_type: CommitType,
        scope: Option<&CommitScope>,
        summary: &CommitSummary,
        breaking_note: Option<&BreakingNote>,
    ) -> Result<Self, ValidationError> {
        let bang = if breaking_note.is_some() { "!" } else { "" };

        let subject = if let Some(scope) = scope {
            format!(
                "{}({}){}: {}",
                commit_type,
                scope.as_str(),
                bang,
                summary.as_str()
            )
        } else {
            format!("{}{}: {}", commit_type, bang, summary.as_str())
        };

        let subject_length = subject.len();
        if subject_length > 50 {
            let prefix_without_summary = subject.replace(summary.as_str(), "");
            let budget = 50 - prefix_without_summary.len();
            return Err(ValidationError::SubjectTooLong {
                len: subject_length,
                budget,
                subject,
            });
        }

        Ok(CommitSubject(subject))
    }

    fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Parser, Debug)]
#[command(name = "git-conventional-commit")]
#[command(about = "Create a conventional commit with proper formatting", long_about = None)]
struct Args {
    /// Commit type
    commit_type: CommitType,

    /// Commit summary (required unless using --fixup)
    #[arg(long)]
    summary: Option<CommitSummary>,

    /// Optional scope for the commit
    #[arg(long)]
    scope: Option<CommitScope>,

    /// Optional commit body
    #[arg(long)]
    body: Option<CommitBody>,

    /// Optional breaking change note
    #[arg(long)]
    breaking_note: Option<BreakingNote>,

    /// Commit SHA to create fixup commit for
    #[arg(long)]
    fixup: Option<GitRef>,

    /// Show what would be done without making changes
    #[arg(long)]
    dry_run: bool,

    /// Allow leaving unstaged or untracked changes in the working tree
    #[arg(long)]
    allow_dirty: bool,

    /// Show verbose output
    #[arg(long, short)]
    verbose: bool,

    /// Additional arguments to pass to git commit
    #[arg(trailing_var_arg = true, allow_hyphen_values = true, hide = true)]
    git_args: Vec<String>,
}

fn main() {
    // Handle --help in raw args before clap parsing
    let raw_args: Vec<String> = std::env::args().collect();
    if raw_args.iter().any(|arg| arg == "--help" || arg == "-h") {
        Args::parse_from(&["git-conventional-commit", "--help"]);
        return;
    }

    let args = Args::parse();

    // Check we're in a git repository
    let repo_check = Command::new("git")
        .args(&["rev-parse", "--git-dir"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .expect("Failed to execute git rev-parse");

    if !repo_check.success() {
        eprintln!("✗ ERROR: Not a git repository (or any of the parent directories).");
        eprintln!("NEXT: cd into a repo, or run: git init");
        exit(EXIT_DATAERR);
    }

    if !args.allow_dirty {
        match collect_unstaged_untracked() {
            Ok((unstaged, untracked)) => {
                if !unstaged.is_empty() || !untracked.is_empty() {
                    eprintln!("✗ ERROR: Unstaged or untracked changes detected");
                    eprintln!(
                        "NEXT: Stage changes or rerun with --allow-dirty to allow committing with a dirty working tree"
                    );

                    if !unstaged.is_empty() {
                        eprintln!("UNSTAGED:");
                        for path in &unstaged {
                            eprintln!("  - {}", path);
                        }
                    }

                    if !untracked.is_empty() {
                        eprintln!("UNTRACKED:");
                        for path in &untracked {
                            eprintln!("  - {}", path);
                        }
                    }

                    exit(EXIT_DATAERR);
                }
            }
            Err(message) => {
                eprintln!("✗ ERROR: {}", message);
                exit(EXIT_SOFTWARE);
            }
        }
    }

    // Handle fixup commits (GitRef is already validated and resolved to SHA)
    if let Some(fixup_ref) = &args.fixup {
        let fixup_sha = fixup_ref.as_str();

        if args.dry_run {
            println!(
                "[DRY RUN] Would create fixup commit for {}",
                &fixup_sha[..7]
            );
            println!("[DRY RUN] Would run: git commit --fixup {}", fixup_sha);
            exit(EXIT_OK);
        }

        let mut cmd = Command::new("git");
        cmd.arg("commit").arg("--fixup").arg(fixup_sha);

        for arg in &args.git_args {
            cmd.arg(arg);
        }

        let status = cmd.status().expect("Failed to execute git commit");

        if !status.success() {
            eprintln!("✗ ERROR: git commit failed");
            exit(status.code().unwrap_or(EXIT_SOFTWARE));
        }

        exit(EXIT_OK);
    }

    // Validate that summary is provided when not using fixup
    let summary = args
        .summary
        .as_ref()
        .ok_or_else(|| {
            eprintln!("✗ ERROR: --summary is required when not using --fixup");
            eprintln!("NEXT: Add --summary <text> or use --fixup <commit>");
            exit(EXIT_USAGE);
        })
        .unwrap();

    let commit_type = args.commit_type;
    let scope = args.scope.as_ref();
    let breaking_note = args.breaking_note.as_ref();
    let body = args.body.as_ref();

    // Build full commit message
    let subject = match CommitSubject::new(commit_type, scope, summary, breaking_note) {
        Ok(s) => s,
        Err(e) => {
            eprintln!("✗ ERROR: {}", e);
            exit(EXIT_USAGE);
        }
    };

    let commit_message = new_commit_message(&subject, body, breaking_note);

    if args.verbose || args.dry_run {
        println!("→ Commit message:");
        for line in commit_message.lines() {
            println!("  {}", line);
        }
    }

    if args.dry_run {
        println!("✓ [DRY RUN] Commit message would be valid");
        exit(EXIT_OK);
    }

    // Run commitizen validation if available
    let cz_check = Command::new("cz")
        .args(&["check", "--message", &commit_message])
        .output();

    if let Ok(output) = cz_check {
        if !output.status.success() {
            let error_output = if output.stderr.is_empty() {
                String::from_utf8_lossy(&output.stdout)
            } else {
                String::from_utf8_lossy(&output.stderr)
            };

            eprintln!("✗ ERROR: Commit message does not follow conventional commit format");
            eprintln!("{}", error_output.trim());
            eprintln!();
            eprintln!("MESSAGE:");
            eprintln!("{}", commit_message);
            exit(EXIT_USAGE);
        }
    }

    // Create commit
    let mut commit_cmd = Command::new("git");
    commit_cmd
        .arg("commit")
        .arg("--message")
        .arg(&commit_message);

    for arg in &args.git_args {
        commit_cmd.arg(arg);
    }

    let commit_output = commit_cmd.output();

    match commit_output {
        Ok(output) if output.status.success() => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            print!("{}", stdout);

            // Parse branch, commit_id, and subject from git commit output
            let first_line = stdout.lines().next().unwrap_or("");

            if first_line.contains("detached HEAD") {
                let re = Regex::new(r"\[detached HEAD ([^\]]+)\] (.+)").unwrap();
                if let Some(caps) = re.captures(first_line) {
                    if args.verbose {
                        println!("✓ Created commit {} with subject: {}", &caps[1], &caps[2]);
                    }
                }
            } else {
                let re = Regex::new(r"\[([^ ]+) ([^\]]+)\] (.+)").unwrap();
                if let Some(caps) = re.captures(first_line) {
                    if args.verbose {
                        println!(
                            "✓ Created commit {} on branch {} with subject: {}",
                            &caps[2], &caps[1], &caps[3]
                        );
                    }
                }
            }
            exit(EXIT_OK);
        }
        Ok(output) => {
            eprintln!("✗ ERROR: Failed to create commit (git hooks or other error)");
            eprint!("{}", String::from_utf8_lossy(&output.stderr));
            exit(output.status.code().unwrap_or(EXIT_SOFTWARE));
        }
        Err(e) => {
            eprintln!("✗ ERROR: Failed to run git commit: {}", e);
            exit(EXIT_SOFTWARE);
        }
    }
}

fn new_commit_message(
    subject: &CommitSubject,
    body: Option<&CommitBody>,
    breaking_note: Option<&BreakingNote>,
) -> String {
    let mut message_parts = vec![subject.as_str().to_string()];

    if let Some(body) = body {
        message_parts.push(String::new());
        message_parts.push(body.as_str().to_string());
    }

    if let Some(breaking_note) = breaking_note {
        message_parts.push(String::new());
        message_parts.push(format!("BREAKING CHANGE: {}", breaking_note.as_str()));
    }

    message_parts.join("\n")
}

fn collect_unstaged_untracked() -> Result<(Vec<String>, Vec<String>), String> {
    let unstaged_output = Command::new("git")
        .args(&["ls-files", "--modified"])
        .output()
        .map_err(|e| format!("Failed to execute git ls-files --modified: {}", e))?;

    if !unstaged_output.status.success() {
        return Err("git ls-files --modified failed".to_string());
    }

    let unstaged = String::from_utf8_lossy(&unstaged_output.stdout)
        .lines()
        .map(|line| line.to_string())
        .collect();

    let untracked_output = Command::new("git")
        .args(&["ls-files", "--others", "--exclude-standard"])
        .output()
        .map_err(|e| {
            format!(
                "Failed to execute git ls-files --others --exclude-standard: {}",
                e
            )
        })?;

    if !untracked_output.status.success() {
        return Err("git ls-files --others --exclude-standard failed".to_string());
    }

    let untracked = String::from_utf8_lossy(&untracked_output.stdout)
        .lines()
        .map(|line| line.to_string())
        .collect();

    Ok((unstaged, untracked))
}
