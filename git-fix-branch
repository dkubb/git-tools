#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap = { version = "4.5.48", features = ["derive"] }
//! thiserror = "2.0.17"
//! ```
//!
//! Fix branch commit data to be the same as author data

#![forbid(unsafe_code)]
#![deny(clippy::all)]
#![deny(clippy::pedantic)]
#![deny(clippy::nursery)]
#![deny(clippy::cargo)]
#![deny(clippy::complexity)]
#![deny(clippy::correctness)]
#![deny(clippy::perf)]
#![deny(clippy::style)]
#![deny(clippy::suspicious)]
#![expect(
    clippy::blanket_clippy_restriction_lints,
    reason = "Required to enable the clippy::restriction lint group"
)]
#![deny(clippy::restriction)]
#![deny(
    clippy::exhaustive_enums,
    reason = "force all enums to use allow(clippy::exhaustive_enums)"
)]
#![deny(
    clippy::exhaustive_structs,
    reason = "force all structs to use allow(clippy::exhaustive_structs)"
)]
#![expect(
    clippy::implicit_return,
    reason = "Implicit returns keep the code idiomatic while restriction lint conflicts with pedantic"
)]
#![expect(
    clippy::question_mark_used,
    reason = "The `?` operator makes error handling concise without sacrificing clarity"
)]
#![expect(
    clippy::print_stderr,
    reason = "CLI script reports diagnostics directly to stderr"
)]
#![expect(
    clippy::print_stdout,
    reason = "CLI script reports user-facing messages directly to stdout"
)]
#![expect(
    clippy::single_call_fn,
    reason = "Extracting functions improves code organization and readability"
)]
#![expect(
    clippy::too_many_lines,
    reason = "Main function contains comprehensive error handling and user interaction"
)]
#![expect(
    clippy::pattern_type_mismatch,
    reason = "Pattern matching provides clearer intent"
)]
#![expect(
    clippy::non_ascii_literal,
    reason = "Unicode symbols improve CLI user experience with visual indicators"
)]
#![expect(
    clippy::exit,
    reason = "Direct exit is appropriate for CLI scripts with explicit error codes"
)]

use clap::Parser;
use core::str::FromStr;
use std::process::{Command, Stdio, exit};
use thiserror::Error;

/// Successful exit code
const EXIT_OK: i32 = 0;

/// Exit code for bad input / not found
const EXIT_DATAERR: i32 = 65;

/// Exit code for unexpected internal failure
const EXIT_SOFTWARE: i32 = 70;

/// Validation errors for git references
#[derive(Debug, Error)]
enum ValidationError {
    /// Reference cannot be empty
    #[error("Git reference cannot be empty")]
    RefEmpty,

    /// Reference was not found in the repository
    #[error("Git reference not found: {ref_name}")]
    RefNotFound {
        /// The name of the reference that was not found
        ref_name: String,
    },

    /// Failed to execute git rev-parse command
    #[error("Failed to execute git rev-parse")]
    RevParseFailed,
}

/// A validated git reference containing its commit SHA
#[derive(Debug, Clone)]
struct GitRef(String);

impl FromStr for GitRef {
    type Err = ValidationError;

    /// Creates a `GitRef` from a string reference name
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        if input.is_empty() {
            return Err(ValidationError::RefEmpty);
        }

        // Validate that the ref exists using git rev-parse
        let sha = validate_git_ref(input)?;
        Ok(Self(sha))
    }
}

impl GitRef {
    /// Returns the SHA string of this git reference
    fn as_str(&self) -> &str {
        &self.0
    }
}

/// Command line arguments for git-fix-branch
#[derive(Parser, Debug)]
#[command(name = "git-fix-branch")]
#[command(about = "Fix branch commit data to be the same as author data", long_about = None)]
struct Args {
    /// Show what would be done without making changes
    #[arg(long)]
    dry_run: bool,

    /// Parent branch to rebase on
    parent: Option<GitRef>,

    /// Rewrite the entire branch back to the repository root
    #[arg(long)]
    root: bool,
}

/// Range of commits to be processed
#[derive(Clone)]
enum CommitRange {
    /// Commits from a parent reference to HEAD (inclusive)
    ParentRange(String),

    /// All commits from the repository root to HEAD
    RootRange,
}

/// Validates that a git reference exists and returns its commit SHA
fn validate_git_ref(ref_name: &str) -> Result<String, ValidationError> {
    let output = Command::new("git")
        .args(["rev-parse", "--verify", &format!("{ref_name}^{{commit}}")])
        .output()
        .map_err(|_e| ValidationError::RevParseFailed)?;

    if !output.status.success() {
        return Err(ValidationError::RefNotFound {
            ref_name: ref_name.to_owned(),
        });
    }

    Ok(String::from_utf8_lossy(&output.stdout).trim().to_owned())
}

/// Main entry point for git-fix-branch
fn main() {
    let Args {
        parent,
        dry_run,
        root,
    } = Args::parse();

    // Check we're in a git repository
    if Command::new("git")
        .args(["rev-parse", "--git-dir"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_or(true, |status| !status.success())
    {
        eprintln!("✗ ERROR: Not a git repository (or any of the parent directories).");
        eprintln!("NEXT: cd into a repo, or run: git init");
        exit(EXIT_DATAERR);
    }

    if root && parent.is_some() {
        eprintln!("✗ ERROR: --root cannot be used together with a parent reference.");
        eprintln!("NEXT: Omit the parent argument when using --root.");
        exit(EXIT_DATAERR);
    }

    // Get parent branch - use default if not provided
    let resolved_parent = if root {
        None
    } else if let Some(parent_ref) = parent {
        Some(parent_ref)
    } else {
        match resolve_default_branch() {
            Ok(default_branch) => match GitRef::from_str(&default_branch) {
                Ok(git_ref) => Some(git_ref),
                Err(error) => {
                    eprintln!("✗ ERROR: {error}");
                    eprintln!(
                        "NEXT: Provide --parent <branch> or fix the default branch configuration"
                    );
                    exit(EXIT_DATAERR);
                }
            },
            Err(message) => {
                eprintln!("✗ ERROR: {message}");
                eprintln!("NEXT: Provide --parent <branch> or configure init.defaultBranch");
                exit(EXIT_DATAERR);
            }
        }
    };

    if dry_run {
        if let Some(ref_parent) = &resolved_parent {
            println!("→ [DRY RUN] Would rebase on {}", ref_parent.as_str());
        } else {
            println!("→ [DRY RUN] Would skip rebase (root mode)");
        }
        if root {
            println!("→ [DRY RUN] Would fix committer data from the repository root");
        } else {
            println!("→ [DRY RUN] Would fix committer data to match author data");
        }
        println!("✓ [DRY RUN] Branch would be fixed successfully");
        exit(EXIT_OK);
    }

    // Rebase the current branch on top of the parent
    if let Some(ref_parent) = &resolved_parent {
        println!("→ Rebasing on {}", ref_parent.as_str());
        git_run(&["rebase", "--rebase-merges", "--", ref_parent.as_str()]);
    } else {
        println!("→ Skipping rebase (root mode)");
    }

    // Prepare the commit range we're going to inspect or rewrite
    let parent_range = resolved_parent
        .as_ref()
        .map(|parent_ref| format!("{}..HEAD", parent_ref.as_str()));
    let commit_range = match (&parent_range, root) {
        (Some(range), false) => CommitRange::ParentRange(range.to_owned()),
        (None, true) => CommitRange::RootRange,
        _ => {
            eprintln!("✗ ERROR: Unexpected state while determining commit range.");
            exit(EXIT_SOFTWARE);
        }
    };

    // Short-circuit when everything already matches
    match branch_needs_fix(&commit_range) {
        Ok(false) => {
            println!("→ Commits already have matching committer data");
            println!("✓ No rewrite needed");
            exit(EXIT_OK);
        }
        Ok(true) => { /* continue */ }
        Err(message) => {
            eprintln!("✗ ERROR: {message}");
            exit(EXIT_SOFTWARE);
        }
    }

    // Rewrite all commits to use the author data
    if root {
        println!("→ Fixing committer data to match author data from the repository root");
    } else {
        println!("→ Fixing committer data to match author data");
    }

    let env_filter = r#"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_DATE="$GIT_AUTHOR_DATE"
"#;

    let mut command = Command::new("git");
    command.args(["filter-branch", "--force", "--env-filter", env_filter, "--"]);

    match (&commit_range, root) {
        (CommitRange::ParentRange(range), false) => {
            command.arg(range);
        }
        (CommitRange::RootRange, true) => {
            command.args(["--root", "HEAD"]);
        }
        _ => {
            eprintln!("✗ ERROR: Unexpected state while preparing git filter-branch.");
            exit(EXIT_SOFTWARE);
        }
    }

    let result = command
        .env("FILTER_BRANCH_SQUELCH_WARNING", "1")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output();

    match result {
        Ok(output) if output.status.success() => {
            emit_filter_branch_output(&output.stdout, &output.stderr);

            match git_head_sha() {
                Ok(after_head) => {
                    println!("Rewrite {after_head}");
                }
                Err(message) => {
                    eprintln!("✗ ERROR: {message}");
                    exit(EXIT_SOFTWARE);
                }
            }

            println!("✓ Branch fixed successfully");
            exit(EXIT_OK);
        }
        Ok(output) => {
            emit_filter_branch_output(&output.stdout, &output.stderr);
            eprintln!("✗ ERROR: git filter-branch failed");
            exit(EXIT_SOFTWARE);
        }
        Err(error) => {
            eprintln!("✗ ERROR: Failed to execute git filter-branch");
            eprintln!("DETAILS: {error}");
            exit(EXIT_SOFTWARE);
        }
    }
}

/// Executes a git command with the given arguments, exiting on failure
fn git_run(args: &[&str]) {
    let status = match Command::new("git").args(args).status() {
        Ok(status) => status,
        Err(error) => {
            eprintln!("✗ ERROR: Failed to execute git {}", args.join(" "));
            eprintln!("DETAILS: {error}");
            exit(EXIT_SOFTWARE);
        }
    };

    if !status.success() {
        eprintln!("✗ ERROR: git {} failed", args.join(" "));
        exit(EXIT_SOFTWARE);
    }
}

/// Executes a git command and returns stdout as a string, or None if the command fails
fn git_output_optional(args: &[&str]) -> Option<String> {
    let output = Command::new("git").args(args).output().ok()?;
    if !output.status.success() {
        return None;
    }
    let value = String::from_utf8_lossy(&output.stdout).trim().to_owned();
    if value.is_empty() { None } else { Some(value) }
}

/// Checks if a branch with the given name exists locally
fn branch_exists(name: &str) -> bool {
    Command::new("git")
        .args([
            "show-ref",
            "--verify",
            "--quiet",
            &format!("refs/heads/{name}"),
        ])
        .status()
        .map(|status| status.success())
        .unwrap_or(false)
}

/// Resolves the default branch name using git configuration or common fallbacks
fn resolve_default_branch() -> Result<String, String> {
    if let Some(value) = git_output_optional(&["config", "init.defaultBranch"]) {
        return Ok(value);
    }

    if let Some(symbolic) =
        git_output_optional(&["symbolic-ref", "--quiet", "refs/remotes/origin/HEAD"])
    {
        let branch_name = symbolic
            .strip_prefix("refs/remotes/origin/")
            .filter(|content| !content.is_empty())
            .unwrap_or(&symbolic);

        if !branch_name.is_empty() {
            return Ok(branch_name.to_owned());
        }
    }

    ["main", "master"]
        .iter()
        .find(|&&candidate| branch_exists(candidate))
        .map(|&candidate| candidate.to_owned())
        .ok_or_else(|| {
            String::from("Unable to determine default branch (checked init.defaultBranch, origin/HEAD, and common fallbacks)")
        })
}

/// Checks if any commits in the given range need committer data fixing
fn branch_needs_fix(range: &CommitRange) -> Result<bool, String> {
    let mut command = Command::new("git");
    command.args(["log", "--format=%an%x00%ae%x00%ad%x00%cn%x00%ce%x00%cd"]);

    match range {
        CommitRange::ParentRange(spec) => command.arg(spec),
        CommitRange::RootRange => command.arg("HEAD"),
    };

    let output = command
        .output()
        .map_err(|error| format!("Failed to inspect commit metadata: {error}"))?;

    if !output.status.success() {
        return Err(String::from("git log failed when checking commit metadata"));
    }

    if output.stdout.is_empty() {
        return Ok(false);
    }

    for line in String::from_utf8_lossy(&output.stdout).lines() {
        let mut parts = line.split('\0');
        let author_name = parts.next().unwrap_or_default();
        let author_email = parts.next().unwrap_or_default();
        let author_date = parts.next().unwrap_or_default();
        let committer_name = parts.next().unwrap_or_default();
        let committer_email = parts.next().unwrap_or_default();
        let committer_date = parts.next().unwrap_or_default();

        if author_name != committer_name
            || author_email != committer_email
            || author_date != committer_date
        {
            return Ok(true);
        }
    }

    Ok(false)
}

/// Gets the current HEAD commit SHA
fn git_head_sha() -> Result<String, String> {
    let output = Command::new("git")
        .args(["rev-parse", "HEAD"])
        .output()
        .map_err(|error| format!("Failed to determine current HEAD: {error}"))?;
    if !output.status.success() {
        return Err(String::from("git rev-parse HEAD failed"));
    }
    Ok(String::from_utf8_lossy(&output.stdout).trim().to_owned())
}

/// Emits git filter-branch output to stdout, filtering out rewrite messages
fn emit_filter_branch_output(stdout: &[u8], stderr: &[u8]) {
    for content in [stdout, stderr] {
        if content.is_empty() {
            continue;
        }

        let text = String::from_utf8_lossy(content).replace('\r', "\n");
        for line in text.lines().map(str::trim).filter(|line| !line.is_empty()) {
            if line.starts_with("Rewrite ") {
                continue;
            }
            println!("{line}");
        }
    }
}
