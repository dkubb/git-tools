#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap = { version = "4.5.48", features = ["derive"] }
//! thiserror = "2.0.17"
//! ```
//!
//! Fix branch commit data to be the same as author data

use clap::Parser;
use std::process::{Command, Stdio, exit};
use std::str::FromStr;
use thiserror::Error;

const EXIT_OK: i32 = 0;
const EXIT_DATAERR: i32 = 65; // bad input / not found
const EXIT_SOFTWARE: i32 = 70; // unexpected internal failure

#[derive(Debug, Error)]
enum ValidationError {
    #[error("Git reference cannot be empty")]
    GitRefEmpty,

    #[error("Failed to execute git rev-parse")]
    GitRevParseFailed,

    #[error("Git reference not found: {ref_name}")]
    GitRefNotFound { ref_name: String },
}

#[derive(Debug, Clone)]
struct GitRef(String);

fn validate_git_ref(ref_name: &str) -> Result<String, ValidationError> {
    let output = Command::new("git")
        .args(&["rev-parse", "--verify", &format!("{}^{{commit}}", ref_name)])
        .output()
        .map_err(|_| ValidationError::GitRevParseFailed)?;

    if !output.status.success() {
        return Err(ValidationError::GitRefNotFound {
            ref_name: ref_name.to_string(),
        });
    }

    Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())
}

impl FromStr for GitRef {
    type Err = ValidationError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ValidationError::GitRefEmpty);
        }

        // Validate that the ref exists using git rev-parse
        let sha = validate_git_ref(s)?;
        Ok(GitRef(sha))
    }
}

impl GitRef {
    fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Parser, Debug)]
#[command(name = "git-fix-branch")]
#[command(about = "Fix branch commit data to be the same as author data", long_about = None)]
struct Args {
    /// Parent branch to rebase on
    parent: Option<GitRef>,

    /// Show what would be done without making changes
    #[arg(long)]
    dry_run: bool,

    /// Rewrite the entire branch back to the repository root
    #[arg(long)]
    root: bool,
}

fn main() {
    let Args {
        parent,
        dry_run,
        root,
    } = Args::parse();

    // Check we're in a git repository
    if Command::new("git")
        .args(&["rev-parse", "--git-dir"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_or(true, |status| !status.success())
    {
        eprintln!("✗ ERROR: Not a git repository (or any of the parent directories).");
        eprintln!("NEXT: cd into a repo, or run: git init");
        exit(EXIT_DATAERR);
    }

    if root && parent.is_some() {
        eprintln!("✗ ERROR: --root cannot be used together with a parent reference.");
        eprintln!("NEXT: Omit the parent argument when using --root.");
        exit(EXIT_DATAERR);
    }

    // Get parent branch - use default if not provided
    let parent = if root {
        None
    } else if let Some(p) = parent {
        Some(p)
    } else {
        match resolve_default_branch() {
            Ok(default_branch) => match GitRef::from_str(&default_branch) {
                Ok(git_ref) => Some(git_ref),
                Err(e) => {
                    eprintln!("✗ ERROR: {}", e);
                    eprintln!(
                        "NEXT: Provide --parent <branch> or fix the default branch configuration"
                    );
                    exit(EXIT_DATAERR);
                }
            },
            Err(message) => {
                eprintln!("✗ ERROR: {}", message);
                eprintln!("NEXT: Provide --parent <branch> or configure init.defaultBranch");
                exit(EXIT_DATAERR);
            }
        }
    };

    if dry_run {
        if let Some(ref parent) = parent {
            println!("→ [DRY RUN] Would rebase on {}", parent.as_str());
        } else {
            println!("→ [DRY RUN] Would skip rebase (root mode)");
        }
        if root {
            println!("→ [DRY RUN] Would fix committer data from the repository root");
        } else {
            println!("→ [DRY RUN] Would fix committer data to match author data");
        }
        println!("✓ [DRY RUN] Branch would be fixed successfully");
        exit(EXIT_OK);
    }

    // Rebase the current branch on top of the parent
    if let Some(ref parent) = parent {
        println!("→ Rebasing on {}", parent.as_str());
        git_run(&["rebase", "--rebase-merges", "--", parent.as_str()]);
    } else {
        println!("→ Skipping rebase (root mode)");
    }

    // Prepare the commit range we're going to inspect or rewrite
    let parent_range = parent.as_ref().map(|p| format!("{}..HEAD", p.as_str()));
    let commit_range = match (&parent_range, root) {
        (Some(range), false) => CommitRange::ParentRange(range.clone()),
        (None, true) => CommitRange::RootRange,
        _ => {
            eprintln!("✗ ERROR: Unexpected state while determining commit range.");
            exit(EXIT_SOFTWARE);
        }
    };

    // Short-circuit when everything already matches
    match branch_needs_fix(&commit_range) {
        Ok(false) => {
            println!("→ Commits already have matching committer data");
            println!("✓ No rewrite needed");
            exit(EXIT_OK);
        }
        Ok(true) => { /* continue */ }
        Err(message) => {
            eprintln!("✗ ERROR: {message}");
            exit(EXIT_SOFTWARE);
        }
    }

    // Rewrite all commits to use the author data
    if root {
        println!("→ Fixing committer data to match author data from the repository root");
    } else {
        println!("→ Fixing committer data to match author data");
    }

    let env_filter = r#"
export GIT_COMMITTER_NAME="$GIT_AUTHOR_NAME"
export GIT_COMMITTER_EMAIL="$GIT_AUTHOR_EMAIL"
export GIT_COMMITTER_DATE="$GIT_AUTHOR_DATE"
"#;

    let mut command = Command::new("git");
    command.args(&[
        "filter-branch",
        "--force",
        "--env-filter",
        env_filter,
        "--"
    ]);

    match (&commit_range, root) {
        (CommitRange::ParentRange(range), false) => {
            command.arg(range);
        }
        (CommitRange::RootRange, true) => {
            command.args(&["--root", "HEAD"]);
        }
        _ => {
            eprintln!("✗ ERROR: Unexpected state while preparing git filter-branch.");
            exit(EXIT_SOFTWARE);
        }
    }

    let result = command
        .env("FILTER_BRANCH_SQUELCH_WARNING", "1")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output();

    match result {
        Ok(output) if output.status.success() => {
            emit_filter_branch_output(&output.stdout, &output.stderr);

            match git_head_sha() {
                Ok(after_head) => {
                    println!("Rewrite {}", after_head);
                }
                Err(message) => {
                    eprintln!("✗ ERROR: {message}");
                    exit(EXIT_SOFTWARE);
                }
            }

            println!("✓ Branch fixed successfully");
            exit(EXIT_OK);
        }
        Ok(output) => {
            emit_filter_branch_output(&output.stdout, &output.stderr);
            eprintln!("✗ ERROR: git filter-branch failed");
            exit(EXIT_SOFTWARE);
        }
        Err(e) => {
            eprintln!("✗ ERROR: Failed to execute git filter-branch");
            eprintln!("DETAILS: {}", e);
            exit(EXIT_SOFTWARE);
        }
    }
}

fn git_run(args: &[&str]) {
    let status = match Command::new("git").args(args).status() {
        Ok(status) => status,
        Err(e) => {
            eprintln!("✗ ERROR: Failed to execute git {}", args.join(" "));
            eprintln!("DETAILS: {}", e);
            exit(EXIT_SOFTWARE);
        }
    };

    if !status.success() {
        eprintln!("✗ ERROR: git {} failed", args.join(" "));
        exit(EXIT_SOFTWARE);
    }
}

fn git_output_optional(args: &[&str]) -> Option<String> {
    let output = Command::new("git").args(args).output().ok()?;
    if !output.status.success() {
        return None;
    }
    let value = String::from_utf8_lossy(&output.stdout).trim().to_string();
    if value.is_empty() { None } else { Some(value) }
}

fn branch_exists(name: &str) -> bool {
    Command::new("git")
        .args(&[
            "show-ref",
            "--verify",
            "--quiet",
            &format!("refs/heads/{}", name),
        ])
        .status()
        .map(|status| status.success())
        .unwrap_or(false)
}

fn resolve_default_branch() -> Result<String, String> {
    if let Some(value) = git_output_optional(&["config", "init.defaultBranch"]) {
        return Ok(value);
    }

    if let Some(symbolic) =
        git_output_optional(&["symbolic-ref", "--quiet", "refs/remotes/origin/HEAD"])
    {
        let branch_name = symbolic
            .strip_prefix("refs/remotes/origin/")
            .filter(|s| !s.is_empty())
            .unwrap_or(&symbolic);

        if !branch_name.is_empty() {
            return Ok(branch_name.to_string());
        }
    }

    ["main", "master"]
        .iter()
        .find(|&&candidate| branch_exists(candidate))
        .map(|candidate| candidate.to_string())
        .ok_or_else(|| {
            "Unable to determine default branch (checked init.defaultBranch, origin/HEAD, and common fallbacks)".to_string()
        })
}

#[derive(Clone)]
enum CommitRange {
    ParentRange(String),
    RootRange,
}

fn branch_needs_fix(range: &CommitRange) -> Result<bool, String> {
    let mut command = Command::new("git");
    command.args(&[
        "log",
        "--format=%an%x00%ae%x00%ad%x00%cn%x00%ce%x00%cd"
    ]);

    match range {
        CommitRange::ParentRange(spec) => command.arg(spec),
        CommitRange::RootRange => command.arg("HEAD"),
    };

    let output = command
        .output()
        .map_err(|e| format!("Failed to inspect commit metadata: {e}"))?;

    if !output.status.success() {
        return Err("git log failed when checking commit metadata".to_string());
    }

    if output.stdout.is_empty() {
        return Ok(false);
    }

    for line in String::from_utf8_lossy(&output.stdout).lines() {
        let mut parts = line.split('\0');
        let author_name = parts.next().unwrap_or_default();
        let author_email = parts.next().unwrap_or_default();
        let author_date = parts.next().unwrap_or_default();
        let committer_name = parts.next().unwrap_or_default();
        let committer_email = parts.next().unwrap_or_default();
        let committer_date = parts.next().unwrap_or_default();

        if author_name != committer_name
            || author_email != committer_email
            || author_date != committer_date
        {
            return Ok(true);
        }
    }

    Ok(false)
}

fn git_head_sha() -> Result<String, String> {
    Command::new("git")
        .args(["rev-parse", "HEAD"])
        .output()
        .map_err(|e| format!("Failed to determine current HEAD: {e}"))
        .and_then(|output| {
            if !output.status.success() {
                return Err("git rev-parse HEAD failed".to_string());
            }
            Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())
        })
}

fn emit_filter_branch_output(stdout: &[u8], stderr: &[u8]) {
    for content in [stdout, stderr] {
        if content.is_empty() {
            continue;
        }

        let text = String::from_utf8_lossy(content).replace('\r', "\n");
        for line in text.lines().map(str::trim).filter(|line| !line.is_empty()) {
            if line.starts_with("Rewrite ") {
                continue;
            }
            println!("{}", line);
        }
    }
}
