#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap = { version = "4.5.48", features = ["derive"] }
//! ```
//!
//! Prune all merged local and remote branches

use clap::Parser;
use regex::Regex;
use std::process::{Command, Stdio, exit};

const EXIT_OK: i32 = 0;
const EXIT_DATAERR: i32 = 65; // bad input / not found
const EXIT_SOFTWARE: i32 = 70; // unexpected internal failure

#[derive(Parser, Debug)]
#[command(name = "git-prune-all")]
#[command(about = "Prune all merged local and remote branches", long_about = None)]
struct Args {
    /// Show what would be done without making changes
    #[arg(long)]
    dry_run: bool,
}

fn main() {
    let args = Args::parse();

    // Check we're in a git repository
    let repo_check = Command::new("git")
        .args(&["rev-parse", "--git-dir"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .expect("Failed to execute git rev-parse");

    if !repo_check.success() {
        eprintln!("✗ ERROR: Not a git repository (or any of the parent directories).");
        eprintln!("NEXT: cd into a repo, or run: git init");
        exit(EXIT_DATAERR);
    }

    // Get current branch
    let branch = git_output(&["rev-parse", "--abbrev-ref", "HEAD"]);

    // Get remote for current branch
    let remote = git_output(&["config", &format!("branch.{}.remote", branch)]);

    // Remove remote references
    println!("→ Updating remote references");
    let _ = Command::new("git")
        .args(&["remote", "update", "--prune"])
        .stdout(Stdio::null())
        .status();

    // Get default branch
    let default_branch = match resolve_default_branch(&remote) {
        Ok(name) => name,
        Err(message) => {
            eprintln!("✗ ERROR: {}", message);
            eprintln!("NEXT: Configure init.defaultBranch or set the remote HEAD");
            exit(EXIT_DATAERR);
        }
    };

    // Remove remote branches
    println!("→ Pruning merged remote branches");
    prune_remote_branches(&branch, &remote, &default_branch, args.dry_run);

    // Remove local branches
    println!("→ Pruning merged local branches");
    prune_local_branches(&branch, args.dry_run);

    println!("✓ Pruning complete");
    exit(EXIT_OK);
}

fn prune_remote_branches(branch: &str, remote: &str, default_branch: &str, dry_run: bool) {
    // Use git branch --format for cleaner output
    let merged_branches = git_output(&[
        "branch",
        "--remotes",
        "--merged",
        &format!("{}/{}", remote, branch),
        "--format=%(refname:short)",
    ]);

    let prefix = format!("{}/", remote);
    let branches: Vec<String> = merged_branches
        .lines()
        .filter_map(|line| line.strip_prefix(&prefix).map(String::from))
        .collect();

    // Filter out protected branches using simpler pattern matching
    let to_delete: Vec<String> = branches
        .into_iter()
        .filter(|b| {
            !b.starts_with("release/")
                && !b.starts_with("pr/")
                && b != default_branch
                && b != branch
        })
        .collect();

    if to_delete.is_empty() {
        println!("  No remote branches to prune");
        return;
    }

    for branch_name in &to_delete {
        if dry_run {
            println!("  [DRY RUN] Would delete remote branch: {}", branch_name);
        } else {
            println!("  Deleting remote branch: {}", branch_name);
        }
    }

    if !dry_run {
        let mut cmd_args = vec!["push", "--delete", "--", remote];
        let branch_refs: Vec<&str> = to_delete.iter().map(|s| s.as_str()).collect();
        cmd_args.extend(branch_refs);

        let _ = Command::new("git").args(&cmd_args).status();
    }
}

fn prune_local_branches(branch: &str, dry_run: bool) {
    let merged_branches = git_output(&["branch", "--merged", branch]);

    // Filter out current branch (marked with *)
    let current_marker = format!("* {}", branch);
    let branches: Vec<String> = merged_branches
        .lines()
        .filter(|line| *line != current_marker)
        .map(|line| line.trim().to_string())
        .collect();

    if branches.is_empty() {
        println!("  No local branches to prune");
        return;
    }

    for branch_name in &branches {
        if dry_run {
            println!("  [DRY RUN] Would delete local branch: {}", branch_name);
        } else {
            println!("  Deleting local branch: {}", branch_name);
        }
    }

    if !dry_run {
        let mut cmd_args = vec!["branch", "--delete", "--"];
        let branch_refs: Vec<&str> = branches.iter().map(|s| s.as_str()).collect();
        cmd_args.extend(branch_refs);

        let _ = Command::new("git").args(&cmd_args).status();
    }
}

fn git_output(args: &[&str]) -> String {
    let output = match Command::new("git").args(args).output() {
        Ok(output) => output,
        Err(e) => {
            eprintln!("✗ ERROR: Failed to execute git {}", args.join(" "));
            eprintln!("DETAILS: {}", e);
            exit(EXIT_SOFTWARE);
        }
    };

    if !output.status.success() {
        eprintln!("✗ ERROR: git {} failed", args.join(" "));
        let stderr = String::from_utf8_lossy(&output.stderr);
        let trimmed = stderr.trim();
        if !trimmed.is_empty() {
            eprintln!("{}", trimmed);
        }
        exit(EXIT_SOFTWARE);
    }

    String::from_utf8_lossy(&output.stdout).trim().to_string()
}

fn git_output_optional(args: &[&str]) -> Option<String> {
    let output = Command::new("git").args(args).output().ok()?;
    if !output.status.success() {
        return None;
    }
    let value = String::from_utf8_lossy(&output.stdout).trim().to_string();
    if value.is_empty() { None } else { Some(value) }
}

fn branch_exists(name: &str) -> bool {
    Command::new("git")
        .args(&[
            "show-ref",
            "--verify",
            "--quiet",
            &format!("refs/heads/{}", name),
        ])
        .status()
        .map(|status| status.success())
        .unwrap_or(false)
}

fn resolve_default_branch(remote: &str) -> Result<String, String> {
    if let Some(value) = git_output_optional(&["config", "init.defaultBranch"]) {
        return Ok(value);
    }

    let remote_head = format!("refs/remotes/{}/HEAD", remote);
    if let Some(symbolic) = git_output_optional(&["symbolic-ref", "--quiet", &remote_head]) {
        let prefix = format!("refs/remotes/{}/", remote);
        let trimmed = symbolic
            .strip_prefix(&prefix)
            .map(|s| s.to_string())
            .unwrap_or(symbolic);
        if !trimmed.is_empty() {
            return Ok(trimmed);
        }
    }

    for candidate in ["main", "master"] {
        if branch_exists(candidate) {
            return Ok(candidate.to_string());
        }
    }

    Err(format!(
        "Unable to determine default branch (checked init.defaultBranch, {}, and common fallbacks)",
        remote_head
    ))
}
