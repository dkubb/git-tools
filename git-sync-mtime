#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap = { version = "4.5.48", features = ["derive"] }
//! chrono = "0.4"
//! filetime = "0.2"
//! rayon = "1.10"
//! ```
//!
//! Fix file mtime to match last git commit date

use chrono::DateTime;
use clap::Parser;
use filetime::{FileTime, set_file_mtime};
use rayon::prelude::*;
use std::collections::{HashMap, HashSet};
use std::path::Path;
use std::process::{Command, Stdio, exit};

const EXIT_OK: i32 = 0;
const EXIT_DATAERR: i32 = 65; // bad input / not found
const EXIT_SOFTWARE: i32 = 70; // unexpected internal failure

#[derive(Parser, Debug)]
#[command(name = "git-sync-mtime")]
#[command(about = "Fix file mtime to match last git commit date", long_about = None)]
struct Args {
    /// Show what would be done without making changes
    #[arg(long)]
    dry_run: bool,
}

fn main() {
    let args = Args::parse();

    // Check we're in a git repository
    let repo_check = Command::new("git")
        .args(&["rev-parse", "--git-dir"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .expect("Failed to execute git rev-parse");

    if !repo_check.success() {
        eprintln!("✗ ERROR: Not a git repository (or any of the parent directories).");
        eprintln!("NEXT: cd into a repo, or run: git init");
        exit(EXIT_DATAERR);
    }

    // List tracked files so we only attempt to sync files that currently exist in the index
    let tracked_files: HashSet<String> = git_output(&["ls-files"])
        .lines()
        .map(str::trim)
        .filter(|line| !line.is_empty())
        .map(|line| line.to_string())
        .collect();

    // Get all file timestamps in a single git command for maximum performance
    // This uses git log with --name-only to output all files with their commit timestamps
    let log_output = git_output_raw(&[
        "log",
        "HEAD",
        "--pretty=format:%H%x00%ct%x00",
        "--name-only",
        "--diff-filter=AMCR",
        "-z",
    ]);

    let tokens: Vec<&[u8]> = log_output
        .split(|&b| b == b'\0')
        .filter(|token| !token.is_empty())
        .collect();

    let mut file_times: HashMap<String, i64> = HashMap::new();
    let mut idx = 0usize;
    while idx + 1 < tokens.len() {
        let commit_token = trim_leading_newlines(tokens[idx]);
        let timestamp_token = trim_leading_newlines(tokens[idx + 1]);

        if !is_commit_hash(commit_token) {
            idx += 1;
            continue;
        }

        let commit_time = match parse_timestamp(timestamp_token) {
            Some(ts) => ts,
            None => {
                idx += 1;
                continue;
            }
        };

        idx += 2;

        while idx < tokens.len() {
            let token = trim_leading_newlines(tokens[idx]);
            if token.is_empty() {
                idx += 1;
                continue;
            }

            // If the token looks like the start of the next commit and has a timestamp following it, break.
            if is_commit_hash(token)
                && idx + 1 < tokens.len()
                && parse_timestamp(trim_leading_newlines(tokens[idx + 1])).is_some()
            {
                break;
            }

            if let Ok(file) = String::from_utf8(token.to_vec()) {
                if tracked_files.contains(&file) && !file_times.contains_key(&file) {
                    file_times.insert(file, commit_time);
                    if file_times.len() == tracked_files.len() {
                        break;
                    }
                }
            }

            idx += 1;
        }

        // Move past any file tokens we consumed; if we exited early due to matching next commit, loop will handle parsing from there.
        if file_times.len() == tracked_files.len() {
            break;
        }
    }

    // Process files in parallel for maximum performance
    let entries: Vec<_> = file_times
        .into_iter()
        .filter(|(file, _)| tracked_files.contains(file))
        .collect();

    if entries.is_empty() {
        println!("✓ No files to sync");
        exit(EXIT_OK);
    }

    println!("→ Syncing mtime for {} files", entries.len());
    entries.par_iter().for_each(|(file, timestamp)| {
        let path = Path::new(file);
        if !path.exists() {
            return;
        }

        if args.dry_run {
            if let Some(dt) = DateTime::from_timestamp(*timestamp, 0) {
                println!(
                    "  [DRY RUN] Would set {} - {}",
                    dt.format("%Y-%m-%d %H:%M:%S"),
                    file
                );
            }
        } else {
            let filetime = FileTime::from_unix_time(*timestamp, 0);
            match set_file_mtime(file, filetime) {
                Ok(_) => {
                    if let Some(dt) = DateTime::from_timestamp(*timestamp, 0) {
                        println!("  {} - {}", dt.format("%Y-%m-%d %H:%M:%S"), file);
                    }
                }
                Err(e) => {
                    eprintln!("  ✗ Failed to update mtime for {}: {}", file, e);
                }
            }
        }
    });

    println!("✓ Mtime sync complete");
    exit(EXIT_OK);
}

fn git_output(args: &[&str]) -> String {
    let stdout = git_output_raw(args);
    String::from_utf8_lossy(&stdout).trim().to_string()
}

fn git_output_raw(args: &[&str]) -> Vec<u8> {
    let output = match Command::new("git").args(args).output() {
        Ok(output) => output,
        Err(e) => {
            eprintln!("✗ ERROR: Failed to execute git {}", args.join(" "));
            eprintln!("DETAILS: {}", e);
            exit(EXIT_SOFTWARE);
        }
    };

    if !output.status.success() {
        eprintln!("✗ ERROR: git {} failed", args.join(" "));
        let stderr = String::from_utf8_lossy(&output.stderr);
        let trimmed = stderr.trim();
        if !trimmed.is_empty() {
            eprintln!("{}", trimmed);
        }
        exit(EXIT_SOFTWARE);
    }

    output.stdout
}

fn parse_timestamp(token: &[u8]) -> Option<i64> {
    if token.is_empty() || token.iter().any(|b| !b.is_ascii_digit()) {
        return None;
    }

    let value = std::str::from_utf8(token).ok()?;
    value.parse::<i64>().ok()
}

fn trim_leading_newlines(token: &[u8]) -> &[u8] {
    if token.starts_with(b"\r\n") {
        &token[2..]
    } else if token.starts_with(b"\n") || token.starts_with(b"\r") {
        &token[1..]
    } else {
        token
    }
}

fn is_commit_hash(token: &[u8]) -> bool {
    token.len() == 40 && token.iter().all(|b| b.is_ascii_hexdigit())
}
